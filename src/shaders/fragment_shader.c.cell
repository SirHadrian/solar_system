varying vec2 vertexUV;
varying vec3 vertexPosition;
varying vec3 vertexNormal;

uniform float T;
uniform vec2 R;

#define FC gl_FragCoord

#define PI 3.14159265359
#define S(a, b, x) smoothstep(a, b, x)

// A cell size of 1. is equal with a space divizion.
#define CELL_SIZE 1.
// If the uv space is too big the lines will disappear.
// Increase the line size to make them appear.
#define LINE_SIZE 0.01

vec3 draw_grid(vec3 uv) {

  // Draw grid.
  vec3 lines = vec3(0.);
  if (mod(uv.x, CELL_SIZE) < LINE_SIZE)
    lines = vec3(.7);
  if (mod(uv.y, CELL_SIZE) < LINE_SIZE)
    lines = vec3(.7);
  if (mod(uv.z, CELL_SIZE) < LINE_SIZE)
    lines = vec3(.7);

  // Draw axes.
  if (abs(uv.x) < LINE_SIZE)
    lines.r = 1.;
  if (abs(uv.y) < LINE_SIZE)
    lines.g = 1.;
  if (abs(uv.z) < LINE_SIZE)
    lines.b = 1.;

  return lines;
}

float hash(vec3 seed) {
  vec3 m1 = vec3(324345., 435424., 453324.);
  float m2 = 345232.;

  return fract(sin(dot(seed, m1)) * m2);
}

void main() {

  vec3 uv = vertexPosition;

  vec3 color = vec3(0.);

  vec3 id = floor(uv);
  vec3 gv = fract(uv);

  float mdist = 1.;

  for (float z = -1.; z <= 1.; z += 1.) {
    for (float y = -1.; y <= 1.; y += 1.) {
      for (float x = -1.; x <= 1.; x += 1.) {

        vec3 neighbor = vec3(x, y, z);

        float rand = hash(id + neighbor);

        vec3 point = vec3(rand, fract(rand * 324325.), fract(rand * 53455.));

        point = .5 + .5 * sin(T * point);

        vec3 offset = point + neighbor;

        float dist = length(gv - offset);
        mdist = min(mdist, dist);
      }
    }
  }

  color += mdist;

  // color += hash(gv);

  // color += gv;

  // color += draw_grid(uv);

  gl_FragColor = vec4(color, 1.);
}
